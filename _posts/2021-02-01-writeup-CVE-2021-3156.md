---
layout: post
title: 【kernel exploit】CVE-2021-3156 sudo漏洞分析与利用
categories: Kernel-exploit
description: 【kernel exploit】CVE-2021-3156 sudo漏洞分析与利用
keywords: CVE, Kernel, Exploit
---

**影响版本**：

- 1.9.0 <= Sudo <= 1.9.5 p1 所有稳定版（默认配置） 

- 1.8.2 <= Sudo <= 1.8.31 p2 所有老版本

- 最新的系统，如Ubuntu 20.04 (Sudo 1.8.31), Debian 10 (Sudo 1.8.27), Fedora 33 (Sudo 1.9.2) 都受到影响。

**编译选项**：

```bash
# 编译
$ wget https://github.com/sudo-project/sudo/archive/SUDO_1_9_5p1.tar.gz
$ tar xf sudo-SUDO_1_9_5p1.tar.gz 
$ cd sudo-SUDO_1_9_5p1/
$ mkdir build
$ cd build/
$ ../configure --enable-env-debug
$ make -j
$ sudo make install
# 调试 （需以root运行gdb，漏洞代码是动态加载的，直接下断点下不到，crash之后再下）
$ gdb --args sudoedit -s '\' `perl -e 'print "A" x 65536'`
$ b ../../../plugins/sudoers/sudoers.c:964
$ b ../../../plugins/sudoers/sudoers.c:978
```

**漏洞描述**：CVE-2021-3156（该漏洞被命名为“Baron Samedit”）——sudo在命令参数中转义反斜杠时存在堆缓冲区溢出。当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或 -i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是 /etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。漏洞引入时间为2011年7月（commit 8255ed69），漏洞存在时间达10年。

**补丁**：目前官方已在sudo新版本1.9.5 p2中修复了该漏洞，官方下载链接：https://www.sudo.ws/download.html

**测试版本**：Ubuntu 19.04 [exploit](https://github.com/blasty/CVE-2021-3156)

**利用过程**：



## 1.sudo简介

sudo是可以允许管理员让普通用户执行root命令的1个工具，相当于su或者halt的命令，这样可以减少root登陆时间和管理，也可以提高linux系统的安全性。

## 2.漏洞检测

检测是否含有此漏洞：

- 在非root权限下，运行命令`$ sudoedit -s /`。
- 若出现以`sudoedit：`开头的错误响应，则系统受到此漏洞影响；
- 若出现以`usage：`开头的错误响应，则表示该漏洞已被补丁修复。

## 3.漏洞分析

命令行模式下运行sudo，输入`-s`选项，会设置sudo的`MODE_SHELL` flag；输入`-i`选项，会设置sudo的`MODE_SHELL` flag 和 `MODE_LOGIN_SHELL` flag。在sudo的`main()` 函数开头，`parse_args()` 会连接所有命令行参数（587-595行）并给元字符加反斜杠（590-591行）来重写 `argv`（609-617行）。

```c
// parse_args()
571     if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) { 
572         char **av, *cmnd = NULL; 
573         int ac = 1; 
... 
581             cmnd = dst = reallocarray(NULL, cmnd_size, 2); 
... 
587             for (av = argv; *av != NULL; av++) { 
588                 for (src = *av; *src != '\0'; src++) { 
589                     /* quote potential meta characters */ 
590                     if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$') 
591                         *dst++ = '\\'; 
592                     *dst++ = *src; 
593                 } 
594                 *dst++ = ' '; 
595             } 
... 
600             ac += 2; /* -c cmnd */ 
... 
603         av = reallocarray(NULL, ac + 1, sizeof(char *)); 
... 
609         av[0] = (char *)user_details.shell; /* plugin may override shell */ 
610         if (cmnd != NULL) { 
611             av[1] = "-c"; 
612             av[2] = cmnd; 
613         } 
614         av[ac] = NULL; 
615  
616         argv = av; 
617         argc = ac; 
618     } 
```

之后，在`sudoers_policy_main()`函数中，`set_cmnd()`连接命令行参数并存入堆缓冲区 `user_args`（864-871行），跳过元字符（866-867行），目的是匹配sudoer和记录日志。

```c
// set_cmnd()
819     if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) { 
... 
852             for (size = 0, av = NewArgv + 1; *av; av++) 
853                 size += strlen(*av) + 1; 
854             if (size == 0 || (user_args = malloc(size)) == NULL) { 
... 
857             } 
858             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { 
... 
864                 for (to = user_args, av = NewArgv + 1; (from = *av); av++) {  // 把命令行参数放入from里面
865                     while (*from) { 
866                         if (from[0] == '\\' && !isspace((unsigned char)from[1])) 
867                             from++; 
868                         *to++ = *from++;  // 将输入的命令行参数拷贝到堆空间 user_args
869                     } 
870                     *to++ = ' '; 
871                 } 
... 
884             } 
... 
886     }
```

但如果命令行参数以1个反斜杠结尾：

- 866行，`from[0]` 是反斜杠，`from[1]`是null结束符（非空格）；
- 867行，from加1，指向null结束符；
- 868行，null结束符被拷贝到`user_args` 堆缓冲区，from又加1，from指向了null结束符后面第1个字符（超出参数的边界）；
- 865-869行，while loop 继续将越界的字符拷贝到`user_args` 堆缓冲区。

所以，`set_cmnd()`存在越界写，溢出`user_args` 堆缓冲区（size是在852-853行中计算）。

## 4.漏洞利用

正常情况下，命令行参数不会以1个反斜杠结尾，流程分析如下：如果设置了`MODE_SHELL` 或 `MODE_LOGIN_SHELL`（858行，到达漏洞代码的必要条件），且设置了`MODE_SHELL`（571行，`parse_args()`换码了元字符，包括反斜杠，末尾的1个反斜杠前又加了1个反斜杠，变成了2个反斜杠，就不存在1个反斜杠结尾的情况了）。

但是，换码代码`parse_args()`和漏洞代码`set_cmnd()`的条件不相同。

```c
// parse_args() 换码代码
571     if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) { 
// set_cmnd() 漏洞代码
819     if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) { 
... 
858             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
```

**问题**：能否设置 `MODE_SHELL` 和 `MODE_EDIT`/`MODE_CHECK` ，但不设置 `MODE_RUN`，这样跳过换码代码`parse_args()`（避免1个反斜杠变成2个反斜杠），直接执行漏洞代码 `set_cmnd()`。

**解答**：不行。只要设置了`MODE_EDIT `（-e, 361行）/`MODE_CHECK`（-l, 423+519行），`parse_args()`就会从`valid_flags`移除`MODE_SHELL`（363+424行），如果此时还设置了`MODE_SHELL`就会报错（532-533行）。

```c
358                 case 'e': 
... 
361                     mode = MODE_EDIT; 
362                     sudo_settings[ARG_SUDOEDIT].value = "true"; 
363                     valid_flags = MODE_NONINTERACTIVE; 
364                     break; 
... 
416                 case 'l': 
... 
423                     mode = MODE_LIST; 
424                     valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST; 
425                     break; 
... 
518     if (argc > 0 && mode == MODE_LIST) 
519         mode = MODE_CHECK; 
... 
532     if ((flags & valid_flags) != flags) 
533         usage(1); 
```

**漏洞**：如果执行`sudoedit`（而非`sudo`），则`parse_args()`会自动设置`MODE_EDIT`（270行）且不会重置`valid_flags`，这样`MODE_SHELL`就还在`valid_flags`中（127+249行），不会报错。

```c
127 #define DEFAULT_VALID_FLAGS     (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL) 
... 
249     int valid_flags = DEFAULT_VALID_FLAGS; 
... 
267     proglen = strlen(progname); 
268     if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) { 
269         progname = "sudoedit"; 
270         mode = MODE_EDIT; 
271         sudo_settings[ARG_SUDOEDIT].value = "true"; 
272     } 
```

**结果**：只要执行`sudoedit -s \`，就能同时设置`MODE_EDIT`和`MODE_SHELL`，但不设置`MODE_RUN`。跳过`parse_args()`中的换码代码，直接执行漏洞代码`set_cmnd()`，溢出`user_args`堆缓冲区。

```bash
$ sudoedit -s '\' `perl -e 'print "A" x 65536'` 
malloc(): corrupted top size
Aborted (core dumped)
```

从攻击者角度来看，该缓冲区溢出可利用的原因如下：

- 1. `user_args`堆缓冲区的size可控（852-854行，size就是命令行参数合并后的长度）；
- 2. 能分别控制size和溢出的内容（第一段命令行参数后紧跟第二段命令行参数，第二段命令行参数不包含在size中）；
- 3. 可以写null字节到`user_args`（每个以单反斜杠结尾的命令行参数或环境变量，都能往`user_args`写1个null字节，见866-868行）。

例如，amd64 Linux中，以下命令会分配24字节的`user_args`缓冲区（实际分配32字节），并将下一个堆块的size覆盖为`A=a\0B=b\0”`（0x00623d4200613d41），fd覆盖为`C=c\0D=d\0`（ 0x00643d4400633d43），bk覆盖为`E=e\0F=f\0` （0x00663d4600653d45）。

```bash
env -i 'AA=a\' 'B=b\' 'C=c\' 'D=d\' 'E=e\' 'F=f' sudoedit -s '1234567890123456789012\' 
--------------------------------------------------------------------- 

--|--------+--------+--------+--------|--------+--------+--------+--------+-- 
  |        |        |12345678|90123456|789012.A|A=a.B=b.|C=c.D=d.|E=e.F=f.| 
--|--------+--------+--------+--------|--------+--------+--------+--------+-- 

              size  <---- user_args buffer ---->  size      fd       bk 
```

## 5.测试exp

exploit来自https://github.com/blasty/CVE-2021-3156，在ubuntu 19.04（sudo版本为1.8.27）下也能成功提权。

![exploit](/images/posts/CVE-2021-3156/exploit.png)



### 参考

[CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit)](https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit)

<https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt>

[cve-2021-3156-sudo堆溢出简单分析](https://www.cnblogs.com/hac425/p/14336484.html)——含调试过程

<https://github.com/blasty/CVE-2021-3156>

<https://github.com/stong/CVE-2021-3156>